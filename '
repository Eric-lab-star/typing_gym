use std::{fs::File, io::{self, Write}};

use clap::{Parser, Subcommand};

fn main() -> Result<(), String> {
    println!("Welcome to Tying Gym");
    println!("Choose your level");
    println!("hard | normal | easy");
    let command = readline()?;

    let args = shlex::split(command.trim()).unwrap();
    let parsed_cli = Cli::try_parse_from(args).map_err(|e|e.to_string());

    match parsed_cli {
        Ok(cli) => match cli.level {
            Level::Hard => level_hard()?,
            Level::Normal => level_hard()?,
            Level::Easy => level_hard()?,
        },
        Err(e) => println!("{}",e),
    }
    Ok(())
}

#[derive(Debug, Parser)]
#[command(multicall = true)]
struct Cli {
    #[command(subcommand)]
    level: Level,
}

#[derive(Debug, Subcommand)]
enum Level {
    Hard,
    Normal,
    Easy,
}

fn readline() -> Result<String, String> {
    
    write!(std::io::stdout(), "$ ").map_err(|e|e.to_string())?;
    std::io::stdout().flush().map_err(|e|e.to_string())?;

    let mut buffer = String::new();
    io::stdin().read_line(&mut buffer).map_err(|e|e.to_string())?;
    Ok(buffer.to_lowercase())
}

fn level_hard() -> Result<(), String> {
    println!(
        r#"hard selected!
type given sentences correctly.
        "#);
    let file = File::open("levels/hard.txt")
        .map_err(|e|format!("failed to open file\n {}", e.to_string()))?;
    let reader = io::BufReader::new(file);

    let mut score = 0;
    let challenge = String::from("using a raw string literal");
    
    println!("{}",challenge);
    let mut buffer = String::new();
    io::stdin().read_line(&mut buffer).map_err(|e|e.to_string())?;
    if challenge == buffer.trim() {
        println!("");
        score += 1;
    } else {
        println!("❌");
    }
    println!("score: {}", score);
    Ok(())

}

fn level_normal() {
    println!("normal selected")
}
fn level_easy() {
    println!("easy selected")
}
